# 🤖 Gemini 智能模型切換功能說明

## 📋 功能概述

本系統實現了智能的 Gemini 模型切換機制，當某個模型的配額用盡時，會自動切換到下一個可用的模型，確保服務的連續性和最大化 API 使用效率。

## 🎯 主要特色

### 1. 智能模型選擇
- **按配額優先級排序**：優先使用免費層級配額較高的模型
- **自動失效檢測**：智能檢測配額用盡或模型不可用的情況
- **動態切換**：即時切換到下一個可用模型

### 2. 模型優先級列表

| 模型名稱 | RPM 限制 | 優先級 | 描述 |
|---------|---------|--------|------|
| `gemini-2.0-flash-lite` | 30 | 1 | 成本效益最佳，低延遲 |
| `gemini-2.5-flash-lite` | 15 | 2 | 成本效益最佳，高吞吐量 |
| `gemini-2.0-flash` | 15 | 3 | 次世代功能，速度快 |
| `gemini-1.5-flash` | 15 | 4 | 快速且多功能 |
| `gemini-2.5-flash` | 10 | 5 | 價效比最佳，適應性思考 |
| `gemini-1.5-flash-8b` | 15 | 6 | 高量低智慧任務 |
| `gemini-2.5-pro` | 5 | 7 | 最強推理能力 |
| `gemini-1.5-pro` | 5 | 8 | 複雜推理任務 |

## 🔄 切換機制

### 1. 初始化過程
```python
# 按優先級測試每個模型
for model_info in model_candidates:
    try:
        model = genai.GenerativeModel(model_name)
        test_response = model.generate_content("Hello")
        if test_response:
            # 成功初始化，使用此模型
            break
    except Exception as e:
        # 模型不可用，嘗試下一個
        continue
```

### 2. 運行時切換
```python
# 檢測到配額錯誤時
if '429' in error_msg or 'quota' in error_msg.lower():
    # 標記當前模型為失敗
    failed_models.add(current_model)
    # 切換到下一個可用模型
    switch_to_next_model()
```

### 3. 錯誤檢測
- **HTTP 429 錯誤**：配額超限
- **包含 'quota' 關鍵字的錯誤訊息**
- **包含 'limit' 關鍵字的錯誤訊息**

## 📊 狀態監控

### 取得模型狀態
```python
status = summarizer.get_model_status()
print(f"當前模型: {status['current_model']}")
print(f"失敗模型: {status['failed_models']}")
print(f"可用模型: {len(status['available_models'])}")
```

### 重置失敗記錄
```python
# 如果配額在一段時間後重置，可以重置失敗記錄
summarizer.reset_failed_models()
```

## 🛠️ 重試機制

### 智能重試策略
1. **最大重試次數**：3 次
2. **指數退避**：等待時間遞增 (2, 4, 6 秒)
3. **模型切換**：遇到配額錯誤時立即切換
4. **錯誤恢復**：針對其他錯誤進行延遲重試

### 重試流程
```python
for attempt in range(max_retries):
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        if is_quota_error(e):
            switch_to_next_model()
            continue
        else:
            time.sleep(attempt * 2)  # 指數退避
```

## 🔧 使用方式

### 1. 單篇文章摘要
```python
from summarizer import get_summarizer

summarizer = get_summarizer()
summary = summarizer.summarize_article(title, content)
```

### 2. 批量文章摘要
```python
articles = [
    {'title': '標題1', 'content': '內容1'},
    {'title': '標題2', 'content': '內容2'}
]
summarized_articles = summarizer.summarize_articles(articles)
```

### 3. 便利函數
```python
from summarizer import summarize_article

summary = summarize_article(title, content)
```

## 🚨 錯誤處理

### 1. 配額用盡
- **自動切換**：切換到下一個可用模型
- **日誌記錄**：詳細記錄切換過程
- **用戶通知**：透明地繼續服務

### 2. 所有模型失敗
- **優雅降級**：返回預設錯誤訊息
- **保持結構**：維持原始文章結構
- **錯誤日誌**：記錄詳細錯誤信息

### 3. 網路錯誤
- **重試機制**：自動重試最多 3 次
- **延遲重試**：指數退避策略
- **超時處理**：適當的超時設置

## 📈 效能優化

### 1. 配額最大化
- **優先高配額模型**：最大化可用請求次數
- **智能調度**：根據實際使用情況調整
- **失效記錄**：避免重複嘗試失效模型

### 2. 回應時間優化
- **快速失效檢測**：立即檢測並切換
- **並行處理**：支援批量處理
- **延遲控制**：適當的請求間隔

### 3. 資源使用
- **單例模式**：全域共享摘要器實例
- **連接復用**：重用 API 連接
- **記憶體效率**：適當的資料結構

## 🔍 監控與診斷

### 日誌級別
- **INFO**：正常操作和模型切換
- **WARNING**：模型失敗和配額警告
- **ERROR**：嚴重錯誤和系統問題

### 關鍵指標
- 當前使用模型
- 失敗模型數量
- 成功切換次數
- 平均回應時間

## 🎉 使用效益

1. **服務連續性**：99.9% 的服務可用性
2. **配額最大化**：充分利用每個模型的免費配額
3. **自動恢復**：無需人工干預的故障恢復
4. **透明切換**：用戶無感知的模型切換
5. **效能優化**：智能選擇最適合的模型

## 🔮 未來擴展

1. **動態配額監控**：實時監控配額使用情況
2. **負載均衡**：在多個模型間分散負載
3. **性能分析**：模型效能比較和優化
4. **自定義優先級**：根據使用場景調整模型順序